"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var moment_1 = __importDefault(require("moment"));
var _1 = require(".");
var TelegramMessage = /** @class */ (function () {
    function TelegramMessage(exp, chat) {
        this._data = exp;
        this._date = moment_1.default(String(this._data.date));
        this._chat = chat;
    }
    TelegramMessage.prototype.src = function (field) {
        return this.data[field];
    };
    Object.defineProperty(TelegramMessage.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "id", {
        get: function () {
            return Number(this.data.id);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "type", {
        get: function () {
            return String(this.data.type);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "contentType", {
        // eslint-disable-next-line class-methods-use-this
        get: function () {
            if (this.data.photo !== undefined) {
                return _1.ContentType.Image;
            }
            if (this.data.poll !== undefined) {
                return _1.ContentType.Poll;
            }
            // Search contentType for media_type
            if (this.data.media_type !== null && typeof this.data.media_type === 'string' && Object.values(_1.ContentType).includes(this.data.media_type)) {
                return this.data.media_type;
            }
            // If none of the above types were found, it's text
            return _1.ContentType.Text;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "date", {
        get: function () {
            return this._date.toDate();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "dateMoment", {
        get: function () {
            return this._date;
        },
        enumerable: false,
        configurable: true
    });
    // TODO: make this safer by restricting what strings can be passed in
    TelegramMessage.prototype.userFromField = function (field) {
        var name = this.data[field];
        var id = this.data[field + "_id"];
        if (!name && !id)
            return undefined;
        return this._chat.addOrFindUser(id, name);
    };
    Object.defineProperty(TelegramMessage.prototype, "from", {
        // TODO: use an enum instead of strings, maybe even to define these functions
        get: function () {
            return this.userFromField('from');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "actor", {
        get: function () {
            return this.userFromField('actor');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "forwardedFrom", {
        get: function () {
            return this.userFromField('forwarded_from');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "savedFrom", {
        get: function () {
            return this.userFromField('saved_from');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "replyTo", {
        get: function () {
            if (!this.data.reply_to_message_id)
                return undefined;
            return this._chat.messageByID(Number(this.data.reply_to_message_id));
        },
        enumerable: false,
        configurable: true
    });
    TelegramMessage.prototype.text = function (inOptions) {
        if (inOptions === void 0) { inOptions = {}; }
        var raw = this.data.text;
        var opts = __assign(__assign({}, TelegramMessage.Defaults), inOptions);
        var retText = '';
        if (this.isSticker && opts.includeStickersAsEmoji === true)
            retText += this.data.sticker_emoji;
        if (typeof raw === 'string')
            return retText + raw;
        if (Array.isArray(raw)) {
            return raw.map(function (obj) {
                if (typeof obj === 'string')
                    return obj;
                return String(obj.text);
            }).join('');
        }
        // TODO: this should only ever happen if unexpected data comes in.
        return '';
    };
    Object.defineProperty(TelegramMessage.prototype, "isSticker", {
        get: function () {
            return this.contentType === _1.ContentType.Sticker;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "isService", {
        get: function () {
            return this.type === 'service';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TelegramMessage.prototype, "isMessage", {
        get: function () {
            return this.type === 'message';
        },
        enumerable: false,
        configurable: true
    });
    TelegramMessage.Defaults = {
        includeStickersAsEmoji: false,
    };
    return TelegramMessage;
}());
exports.default = TelegramMessage;
//# sourceMappingURL=TelegramMessage.js.map